# Virtual File System for Testing (Updated)

This document describes the improved virtual file system abstraction that uses established Rust ecosystem solutions.

## Problem Statement

Previously, tests relied on the real file system of the host machine, which caused several issues:

1. **Environment dependency**: Tests would pass or fail depending on what files/directories existed on the host
2. **Potential harm**: Tests could create files in system directories
3. **Non-deterministic results**: Test outcomes depended on the current state of the host file system
4. **Cleanup issues**: Tests might leave artifacts in the file system

## Solution: Industry-Standard VFS with mockall

Based on feedback, the implementation now uses established Rust ecosystem solutions:
- **`mockall`**: Industry-standard mocking framework for Rust
- **`vfs`**: Available as a development dependency for more complex scenarios

### Core Components

#### `FileSystem` trait (`src/filesystem.rs`)
```rust
#[cfg_attr(test, automock)]
pub trait FileSystem {
    fn exists(&self, path: &Path) -> bool;
    fn is_dir(&self, path: &Path) -> bool;
    fn create_dir_all(&self, path: &Path) -> io::Result<()>;
    fn remove_file(&self, path: &Path) -> io::Result<()>;
    fn write(&self, path: &Path, contents: &[u8]) -> io::Result<()>;
    fn read_to_string(&self, path: &Path) -> io::Result<String>;
    fn canonicalize(&self, path: &Path) -> io::Result<PathBuf>;
    fn metadata(&self, path: &Path) -> io::Result<std::fs::Metadata>;
}
```

#### `RealFileSystem`
- Default implementation for production use
- Delegates all operations to `std::fs` functions
- Maintains existing behavior for production code

#### `MockFileSystem` (Generated by mockall)
- Automatically generated mock using `mockall::automock`
- Allows precise control over expectations and return values
- Industry-standard approach used across the Rust ecosystem

### Usage in Code

#### Production Code
Functions that need file system access now have two versions:
- Public function using `RealFileSystem` (maintains API compatibility)
- Internal function accepting any `FileSystem` implementation

Example:
```rust
// Public API - unchanged for backwards compatibility
pub fn validate_url(input: &str) -> Result<ValidatedUrl> {
    validate_url_with_fs(input, &RealFileSystem)
}

// Internal implementation accepting file system
pub fn validate_url_with_fs<F: FileSystem>(input: &str, fs: &F) -> Result<ValidatedUrl> {
    // Use fs.exists(), fs.canonicalize(), etc.
}
```

#### Test Code
Tests now use `MockFileSystem` for controlled, isolated testing:

```rust
#[test]
fn test_file_validation() {
    let mut mock_fs = MockFileSystem::new();
    
    // Setup precise expectations
    mock_fs
        .expect_exists()
        .with(mockall::predicate::eq(Path::new("/test/file.txt")))
        .return_const(true);
    
    let result = validate_url_with_fs("file:///test/file.txt", &mock_fs);
    assert!(result.is_ok());
}
```

#### Browser Detection Testing
Browser detection now supports mocking without relying on host state:

```rust
#[test]
fn test_browser_detection_with_mock_fs() {
    let mut mock_fs = MockFileSystem::new();
    
    // Mock that only Chrome exists and is executable
    mock_fs.expect_exists()
        .returning(|path| path == Path::new("/usr/bin/google-chrome"));
    
    let browsers = detect_browsers_with_fs(&mock_fs);
    assert!(browsers.iter().any(|b| b.kind == BrowserKind::Chrome));
}
```

### Applied to Existing Functionality

#### Browser Detection
- **`src/browser/linux.rs`**: Updated to use filesystem abstraction
- **Functions**: `detect_browsers_with_fs()`, `resolve_candidate_with_fs()`, etc.
- **Benefits**: Can test browser detection without requiring browsers to be installed

#### URL Validation
- **`src/url.rs`**: Updated for file URL handling
- **Functions**: `validate_url_with_fs()`
- **Benefits**: Test file validation without creating real files

#### Profile Management
- **`src/profile.rs`**: Updated for directory operations
- **Functions**: `prepare_custom_directory_with_fs()`
- **Benefits**: Test profile creation without touching host directories

### Benefits

1. **Uses industry standards**: `mockall` is the de-facto mocking framework for Rust
2. **Precise control**: Setup exact expectations for each test scenario
3. **Isolated tests**: No dependency on host file system state
4. **Predictable results**: Tests always behave the same way
5. **Fast execution**: No actual disk I/O in unit tests
6. **No cleanup needed**: Virtual file system exists only during test execution
7. **Easy test data setup**: Mock exact file/directory states needed for tests

### Files Updated

- `Cargo.toml`: Added `vfs` and `mockall` as dev dependencies
- `src/filesystem.rs`: Simplified file system abstraction using `mockall`
- `src/lib.rs`: Export filesystem module
- `src/url.rs`: Updated to use file system abstraction with comprehensive tests
- `src/profile.rs`: Updated `prepare_custom_directory` to use abstraction
- `src/browser/linux.rs`: Updated browser detection to use abstraction with tests
- `tests/virtual_filesystem_integration.rs`: Enhanced integration tests using temp directories

### Testing Strategy

1. **Unit tests**: Use `MockFileSystem` for fast, isolated testing
2. **Integration tests**: Use `TempDir` for testing real file operations without polluting host system
3. **Browser-dependent tests**: Can now mock browser detection scenarios
4. **Existing tests**: Continue to work unchanged

### Addressing Original Concerns

✅ **Ready solutions in Rust ecosystem**: Now uses `mockall` (industry standard) and `vfs` (available)\
✅ **Applied VFS to existing tests**: Browser detection, URL validation, profile management all use VFS\
✅ **Browser detection without host dependencies**: Can test browser scenarios with controlled mock expectations

### Future Improvements

- Extend VFS to remaining browser modules (macOS, Windows)
- Create helper functions for common mock scenarios
- Consider property-based testing with VFS
- Add VFS integration to profile discovery functions