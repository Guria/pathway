# Virtual File System for Testing

This document describes the virtual file system abstraction using established Rust ecosystem solutions.

## Implementation

### Core Components

#### `FileSystem` trait (`src/filesystem.rs`)
```rust
#[cfg_attr(test, automock)]
pub trait FileSystem {
    fn exists(&self, path: &Path) -> bool;
    fn is_dir(&self, path: &Path) -> bool;
    fn create_dir_all(&self, path: &Path) -> io::Result<()>;
    fn remove_file(&self, path: &Path) -> io::Result<()>;
    fn write(&self, path: &Path, contents: &[u8]) -> io::Result<()>;
    fn read_to_string(&self, path: &Path) -> io::Result<String>;
    fn canonicalize(&self, path: &Path) -> io::Result<PathBuf>;
    fn metadata(&self, path: &Path) -> io::Result<std::fs::Metadata>;
}
```

#### `RealFileSystem`
Production implementation that delegates all operations to `std::fs` functions.

#### `MockFileSystem` (Generated by mockall)
Automatically generated mock using `mockall::automock` for testing with precise control over expectations and return values.

### Usage in Code

#### Production Code
Functions requiring file system access accept a `FileSystem` parameter:

```rust
pub fn validate_url<F: FileSystem>(input: &str, fs: &F) -> Result<ValidatedUrl> {
    // Use fs.exists(), fs.canonicalize(), etc.
}
```

#### Test Code
Tests use `MockFileSystem` for controlled, isolated testing:

```rust
#[test]
fn test_file_validation() {
    let mut mock_fs = MockFileSystem::new();
    
    mock_fs
        .expect_exists()
        .with(mockall::predicate::eq(Path::new("/test/file.txt")))
        .return_const(true);
    
    let result = validate_url("file:///test/file.txt", &mock_fs);
    assert!(result.is_ok());
}
```

#### Browser Detection Testing
Browser detection supports mocking without relying on host state:

```rust
#[test]
fn test_browser_detection_with_mock_fs() {
    let mut mock_fs = MockFileSystem::new();
    
    mock_fs.expect_exists()
        .returning(|path| path == Path::new("/usr/bin/google-chrome"));
    
    let browsers = detect_browsers(&mock_fs);
    assert!(browsers.iter().any(|b| b.kind == BrowserKind::Chrome));
}
```

### Affected Modules

#### Browser Detection
- **`src/browser/linux.rs`**: Functions like `detect_browsers()` use filesystem abstraction
- **Testing**: Can test browser detection without requiring browsers to be installed

#### URL Validation  
- **`src/url.rs`**: Function `validate_url()` uses abstraction for file URL handling
- **Testing**: Test file validation without creating real files

#### Profile Management
- **`src/profile.rs`**: Function `prepare_custom_directory()` uses abstraction for directory operations  
- **Testing**: Test profile creation without touching host directories

### Benefits

1. Uses `mockall` - the de-facto mocking framework for Rust
2. Precise control over test expectations and scenarios
3. Isolated tests with no dependency on host file system state
4. Predictable and consistent test results
5. Fast execution with no actual disk I/O in unit tests
6. No cleanup needed - virtual file system exists only during test execution
7. Easy test data setup by mocking exact file/directory states

### Testing Strategy

1. **Unit tests**: Use `MockFileSystem` for fast, isolated testing
2. **Integration tests**: Use `TempDir` for testing real file operations without polluting host system
3. **Browser-dependent tests**: Mock browser detection scenarios instead of requiring real browsers